"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AbstractCommand_1 = require("../AbstractCommand");
const __1 = require("../..");
class AudioMixerInputCommand extends AbstractCommand_1.default {
    constructor() {
        super(...arguments);
        this.rawName = 'AMIP';
    }
    deserialize(rawCommand) {
        this.index = rawCommand.readUInt16BE(0);
        this.properties = {
            sourceType: rawCommand.readInt8(2),
            portType: rawCommand.readInt8(7),
            mixOption: rawCommand.readInt8(8),
            gain: __1.Util.UInt16BEToDecibel(rawCommand.readUInt16BE(10)),
            balance: __1.Util.IntToBalance(rawCommand.readInt16BE(12))
        };
    }
    serialize() {
        const buffer = Buffer.alloc(12);
        buffer.writeUInt8(this.flag, 0);
        buffer.writeUInt16BE(this.index, 2);
        buffer.writeUInt8(this.properties.mixOption || 0, 4);
        buffer.writeUInt16BE(__1.Util.DecibelToUInt16BE(this.properties.gain || 0), 6);
        buffer.writeInt16BE(__1.Util.BalanceToInt(this.properties.balance || 0), 8);
        return Buffer.concat([
            Buffer.from('CAMI', 'ascii'),
            buffer
        ]);
    }
    applyToState(state) {
        // const channel = state.audio.getChannel(this.index)
        state.audio.channels[this.index] = Object.assign({}, state.audio.channels[this.index], this.properties);
    }
}
AudioMixerInputCommand.MaskFlags = {
    mixOption: 1 << 0,
    gain: 1 << 1,
    balance: 1 << 2
};
exports.AudioMixerInputCommand = AudioMixerInputCommand;
//# sourceMappingURL=AudioMixerInputCommand.js.map